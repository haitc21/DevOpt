# Congifuration Language Style

## 1. Code style

- Luôn chạy `terraform fmt` và `terraform validate` trước khi commit.
- Sử dụng ~[TFLint](https://github.com/terraform-linters/tflint) để áp dụng các **best pratice**.
- Dùng `#` để comment
- Đặt tên resource:
  - Tên là duy nhất
  - Dùng danh từ
  - Tránh từ khóa và resource type
  - Dùng `_` để ngăn cách từ.
- Để các resource con ngay dưới cha
- `variable`:
  - Tên là duy nhất
  - Luôn định nghĩa `type` và `description`.
  - nếu dữ liệu nhạy cảm như password, key... đặt `sensitive = true` để che đi khi `terraform plan` và `terraform apply` tuy nhiên (**trong state vẫn là plan text**.
  - Dùng `validation` block để validate giá trị `variable`.
-`output`: Dùng để xuất các giá trị trong infrastructure ra command line để dễ làm việc (kiểu như console log)
  - Tên là duy nhất
  - Luôn định nghĩa``description`.
- `Local values` tương tự biến trong lập trình
- Tránh lạm dụng `variable` và `local value`.
- Luôn có các giá trị default trong `provider`
- hạn chế sử dụng `count` và `for_each`.
- Sử dụng `.gitignore`

## 2. File names

- **backend.tf** – chứa cấu hình backend của bạn. Bạn có thể định nghĩa nhiều khối `terraform` trong cấu hình để tách biệt phần cấu hình backend khỏi phần cấu hình phiên bản Terraform và provider.
- **main.tf** – chứa tất cả các khối **resource** và **data source**.
- **outputs.tf** – chứa tất cả các khối **output**, được sắp xếp theo thứ tự bảng chữ cái.
- **providers.tf** – chứa tất cả các khối **provider** và phần cấu hình liên quan.
- **terraform.tf** – chứa một khối **terraform** duy nhất, định nghĩa các giá trị **required_version** và **required_providers**.
- **variables.tf** – chứa tất cả các khối **variable**, được sắp xếp theo thứ tự bảng chữ cái.
- **locals.tf** – chứa các giá trị **local**. Tham khảo thêm trong tài liệu về **local values** để biết chi tiết.
- **override.tf** – chứa các định nghĩa **override** cho cấu hình của bạn. Terraform sẽ tải tệp này và tất cả các tệp có đuôi `_override.tf` sau cùng.

## .3 .gitignore

- **Không nên commit các tệp sau:**

| Loại tệp | Giải thích |
|-----------|-------------|
| **`terraform.tfstate`** và **`terraform.tfstate.*`** | Đây là **tệp lưu trạng thái triển khai** (state file). Nó chứa thông tin chi tiết về tài nguyên thật trong môi trường, có thể bao gồm dữ liệu nhạy cảm. |
| **`.terraform.tfstate.lock.info`** | Tệp này được Terraform **tự động tạo và xóa** khi bạn chạy `terraform apply`. Nó dùng để **ngăn chặn việc thay đổi song song (state lock)**. |
| **Thư mục `.terraform/`** | Chứa **các plugin provider**, **module con** và **dữ liệu cache tạm thời** mà Terraform tải về — không cần lưu trong Git. |
| **Các tệp kế hoạch lưu (`*.tfplan`)** | Được tạo khi bạn chạy `terraform plan -out=<file>`. Đây chỉ là tệp trung gian để lưu kế hoạch thực thi, không cần commit. |
| **Các tệp `.tfvars` chứa thông tin nhạy cảm** | Nếu các tệp `.tfvars` có **biến môi trường**, **mật khẩu**, hoặc **khóa API**, **tuyệt đối không commit** chúng. |

---

- **Luôn commit các tệp sau:**

| Loại tệp | Giải thích |
|-----------|-------------|
| **Tất cả tệp mã Terraform (`.tf`, `.tfvars` không nhạy cảm)** | Là phần chính của cấu hình Terraform, cần được version control. |
| **`.terraform.lock.hcl`** | Tệp khóa phụ thuộc (dependency lock file), giúp đảm bảo các provider được sử dụng có cùng phiên bản khi làm việc nhóm. |
| **`.gitignore`** | Chính tệp này — giúp ngăn việc commit các tệp không mong muốn. |
| **`README.md`** | Dùng để mô tả **cấu trúc code**, **biến đầu vào**, và **đầu ra (outputs)** của dự án. |

- [File .gitignore mẫu](https://github.com/github/gitignore/blob/main/Terraform.gitignore)

## 4. Provider Alias

**Provider aliasing** cho phép bạn **định nghĩa nhiều khối `provider`** cho **cùng một Terraform provider**.  
Tính năng này hữu ích khi bạn muốn, ví dụ, **triển khai tài nguyên ở nhiều vùng (region)** trong cùng một cấu hình.

Terraform cung cấp hai meta-argument liên quan:

- `provider` (trong **resource**) — chỉ định provider nào sẽ dùng cho tài nguyên đó.  
- `providers` (trong **module**) — chỉ định provider nào module sẽ sử dụng.

---

providers.tf

```hcl
provider "aws" {
  region = "us-east-1"
}

provider "aws" {
  alias  = "west"
  region = "us-west-2"
}
```

Ở đây:

- aws đầu tiên là default provider (không có alias).
- aws.west là provider alias, được cấu hình cho vùng us-west-2.

main.tf

```hcl
resource "aws_instance" "example" {
  provider = aws.west
  # ...
}

module "aws_vpc" {
  source = "./aws_vpc"
  providers = {
    aws = aws.west
  }
}
```

**Quy tắc quan trọng**

- Provider không có alias → là default provider configuration.
- Luôn khai báo default provider và đặt tất cả provider trong cùng một file (ví dụ: providers.tf).
- Nếu định nghĩa nhiều instance của cùng một provider, hãy:
  - Định nghĩa provider mặc định trước.
  - Đối với provider không mặc định, hãy đặt alias ở dòng đầu tiên trong khối provider.

## 5. Dynamic resource count

Các meta-argument for_each và count cho phép bạn tạo nhiều tài nguyên (resources) từ một khối resource duy nhất, tùy thuộc vào điều kiện tại thời điểm chạy (run-time conditions).

- Nếu các tài nguyên gần như giống hệt nhau, hãy dùng count.
- Nếu một số đối số (arguments) cần giá trị riêng biệt mà bạn không thể suy ra từ số nguyên (index), hãy dùng for_each.
- for_each nhận vào một map hoặc set. Terraform sẽ tạo một instance của tài nguyên đó cho mỗi phần tử trong giá trị bạn truyền vào.
- Meta-argument count cho phép bạn tạo nhiều bản sao (instances) của một tài nguyên từ một khối resource duy nhất.

Ví dụ dưới đây, Terraform tạo các tài nguyên aws_instance tương ứng với các chuỗi trong biến web_instances: "ui", "api", "db", và "metrics".

```hcl
variable "web_instances" {
  type        = list(string)
  description = "Danh sách các instance của ứng dụng web"
  default = [
    "ui",
    "api",
    "db",
    "metrics"
  ]
}

resource "aws_instance" "web" {
  for_each = toset(var.web_instances)
  ami           = data.aws_ami.webapp.id
  instance_type = "t3.micro"
  tags = {
    Name = "web_${each.key}"
  }
}

output "web_private_ips" {
  description = "Các địa chỉ IP riêng của web instances"
  value = {
    for k, v in aws_instance.web : k => v.private_ip
  }
}

output "web_ui_public_ip" {
  description = "Địa chỉ IP công khai của web UI"
  value       = aws_instance.web["ui"].public_ip
}

```

Trong khối resource:

- each.key được dùng để đặt tên duy nhất cho từng instance.
- Output web_private_ips sử dụng for expression để tạo map gồm tên instance và địa chỉ IP riêng tư của chúng.
- Output web_ui_public_ip truy cập trực tiếp public IP của instance có key "ui".
**Output**

````sh
web_private_ips = {
  "api" = "172.31.25.29"
  "db" = "172.31.18.33"
  "metrics" = "172.31.26.112"
  "ui" = "172.31.20.142"
}
web_ui_public_ip = "18.216.208.182"
```

Ví dụ, Terraform chỉ tạo aws_instance nếu biến var.enable_metrics = true:

```hcl
variable "enable_metrics" {
  description = "True nếu cần triển khai máy chủ metrics"
  type        = bool
  default     = true
}

resource "aws_instance" "web" {
  count = var.enable_metrics ? 1 : 0

  ami           = data.aws_ami.webapp.id
  instance_type = "t3.micro"
  ##...
}
```
